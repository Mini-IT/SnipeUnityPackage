---
alwaysApply: false
---

The main contant is splitted into 2 directories: `Runtime/Snipe` and `Runtime/Snipe.Unity`. It is supposed that `Runtime/Snipe.Unity` contains code for wirking with the library int Unity. There are plans to support also other engines. And `Runtime/Snipe` contains a common shared code independant from an engine.

# Directories

- Runtime
    - HttpClient - wrapper for working with HTTP. Used for sigle requests (e.g. external config loading and static files loading) as well as for working as a transport for communicating with backend
    - Integrations - adapters for retrieving external ids for binding user's account (helps users to restore their game accounts and progress)
    - kcp2k - implememtation of KCP protocol for communicating with backend
    - Snipe - common code
        - Communicator - intracting with server
            - API - High-level essences implemented both on the backend and the frontend
                - Tables - abstraction that stores static data loaded from CDN
            - Auth - Handling user accounts and bindings to external IDs
            - Client - Main low-level classes for interacting with the backend
                - Transport - implementations of different transports for interacting with the backend
            - Common - common classes used by other modules
            - Request - classes that wrap request data, send messages to the backend, wait for answers and invoke callbacks as a result of a request
            - SnipeCommunicator - High-level wrapper for `Client`. Hadles states and requests
        - Core - some common classes
        - Logging - debug logging helpers
        - MessagePack - serializater and deserializer
        - Services - internal services
    - Snipe.Unity - Unity boundings
        - Communicator
            - API - High-level implementations if the API modules
                - Tables - loading data form CDN and parsing it into dictionaries
                - UserAttributes - handling data accociated with user's profile on the backend
            - Auth - IDs available form Unity to identify the user
        - Config - remote config - loader for fetching it from server
        - Context - Main high-level abstraction that wraps a single configured instance for working with the library
            - Debug - debug logging helpers
            - Factory - initialization of contexts
            - Manager - Main entry point for interacting with the library from Unity
            - ProfileManager - helpter class for resolving and synchronizing user's profile values (local and remote)
        - Logger
        - Services - Unity-compatible implementations of internal services
- Tests - contains unit tests
- WebSocketJS - implementation of websocket for working in web browsers

# SnipeConfig

`Snipe/Common/SnipeConfig.cs` defines URLs for connection and loading tables and settings for different internal services. Maybe it would be better to rename it to `SnipeOptions`.

Normally the config gets filled once and stay permanent during the whole session, but tt's also a normal situation when SnipeConfig should be reconfigured on the fly (e.g. late remote config data was fetched with different URLs).

# Tables

Normally tables are loaded once and stay unchanged during the whole session even if connection gets lost or the app goes offline. There is always a local copy of the tables on user's device. Initial values are baked into the build; newly loaded ones get saved to cache. So the app can always work even offline.

# Refactoring plan

Current refactoring steps:
1. ~~Remove unused Composition layer (SnipeClientBuilder, SnipeClientScope, ISnipeModule, etc.)~~ DONE
2. Split `AuthSubsystem` — extract `AuthCredentialStore` and `AuthBindingManager`
3. Convert `TablesOptions` from static to instance; nest into `SnipeOptions`
4. Eliminate two-phase init — move `SnipeOptions` to constructor params for `SnipeCommunicator`, `AuthSubsystem`, `SnipeContext`; add `Reconfigure` method
5. Remove LINQ allocations in `AuthSubsystem` (`ToList()`, `FirstOrDefault`)
